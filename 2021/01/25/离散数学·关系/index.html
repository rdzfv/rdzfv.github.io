<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="xyy">





<title>离散数学·关系 | xyy爱吃番茄</title>



    <link rel="icon" href="https://qiniu.xuyuyan.cn/XYY.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
            <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


        
    


<meta name="generator" content="Hexo 5.4.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">xyy爱吃番茄！(个人分享)</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于我</a>
                
                    <a class="menu-item" href="/friends">友链</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">xyy爱吃番茄！(个人分享)</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于我</a>
                
                    <a class="menu-item" href="/friends">友链</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">离散数学·关系</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">xyy</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">一月 25, 2021&nbsp;&nbsp;20:21:30</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/">离散数学</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>本文为《离散数学及其应用》的第九章的笔记</p>
<span id="more"></span>

<p>设 A 和 B 是集合，一个从 A到 B 的二元关系是 $A \times B$ 的子集。换句话说，一个从 A 到 B 的二元关系 R，其中每个有序对的第一个元素取自 A 而第二个元素取自 B。我们使用记号 aRb 表示 $(a, b) \in R$，称为 <strong>a 与 b 有关系 R</strong>。</p>
<h3 id="一、集合的关系"><a href="#一、集合的关系" class="headerlink" title="一、集合的关系"></a>一、集合的关系</h3><p>集合 A 上的关系是 A 到 A 的关系，也就是集合 A 上的关系是 $A \times A$ 的子集。 </p>
<h3 id="二、关系的性质"><a href="#二、关系的性质" class="headerlink" title="二、关系的性质"></a>二、关系的性质</h3><ul>
<li><strong>自反关系</strong>：</li>
</ul>
<p>在某些关系中，某元素总是与自身相关。若对每个元素 $a \in A$，都有 $(a, a) \in R$，那么定义在集合 A 上的关系 R 称为自反的。</p>
<p>用量词描述即为 $\forall a ((a, a) \in R)$。</p>
<ul>
<li><strong>对称关系</strong>：</li>
</ul>
<p>对任意 $a, b \in A$，若只要 $(a, b) \in R$ 就有 $(b, a) \in R$，则称定义在集合 A 上的关系 R 为对称的。</p>
<p>用量词描述即为 $\forall a \forall b((a, b) \in R) \rightarrow (b, a) \in R)$</p>
<ul>
<li><strong>反对称关系</strong>：</li>
</ul>
<p>对任意 $a, b \in A$，若只要 $(a, b) \in R$ 且 $(b, a) \in R$，一定有 $a = b$，则称定义在集合 A 上的关系 R 为反对称的。</p>
<p>用量词描述即为 $\forall a \forall b((a, b) \in R \bigwedge (a, b) \in R) \rightarrow (a=b))$</p>
<ul>
<li><strong>传递关系</strong>：</li>
</ul>
<p>若对于任意 $a, b, c \in A$，$(a, b) \in R$ 并且 $(b, c) \in R$ 则 $(a, c) \in R$，那么定义在集合 A 上的关系 R 称为传递的。</p>
<p>用量词描述即为 $\forall a \forall b \forall c (((a, b) \in R \bigwedge (b, c) \in R) \rightarrow (a, c) \in R)$</p>
<h3 id="三、关系的合成"><a href="#三、关系的合成" class="headerlink" title="三、关系的合成"></a>三、关系的合成</h3><p>设 R 是从集合 A 到集合 B 的关系，S 是从集合 B 到集合 C 的关系。R 和 S 的合成是由有序对 (a, c) 的集合构成的关系，其中 $a \in A$，$c \in C$，并且存在一个 $b \in B$ 的元素，使得 $(a, b) \in R$ 且 $(b, c) \in S$。用符号 $S \circ R$ 表示 S 和 R 的合成。</p>
<ul>
<li>幂的合成</li>
</ul>
<p>设 R 是集合 A 上的关系。R 的 n 次幂 $R^n(n = 1, 2, 3,…)$ 递归地定义为 $R^1 = R$ 和 $R^{n+1} = R^n \circ R$</p>
<ul>
<li>传递关系的幂是该关系的子集</li>
</ul>
<p>集合 A 上的关系 R 是传递的，当且仅当对 n = 1, 2, 3, … 有 $R^n \subseteq R$。</p>
<h3 id="四、n-元关系"><a href="#四、n-元关系" class="headerlink" title="四、n 元关系"></a>四、n 元关系</h3><p>设 $A_1$，$A_2$，…，$A_n$ 是集合。定义在这些集合上的 <strong>n 元关系</strong>是 $A_1 \times A_2 \times … \times A_n$ 的子集。这些集合 $A_1$，$A_2$，…，$A_n$ 称为关系的域，n 称为关系的阶。</p>
<h3 id="五、n-元关系的运算"><a href="#五、n-元关系的运算" class="headerlink" title="五、n 元关系的运算"></a>五、n 元关系的运算</h3><ul>
<li><strong>投影</strong></li>
</ul>
<p>投影 $P_{i_1,i_2,…,i_m}$，其中 $i_1 &lt; i_2 &lt; … &lt; i_m$，将 n 元组 $(a_1, a_2, …,a_n)$ 映射到 m 元组 $(a_{i_1},a_{i_2},…,a_{i_m})$ ，其中 $m \leq n$。</p>
<p>换句话说，投影 $P_{i_1,i_2,…,i_m}$ 删除了 n 元组的 n - m 个分量，保留了 $i_1$，$i_2$，…，$i_m$ 个分量。</p>
<p>上述定义比较抽象，此处我们借用一个例子来说明：当对四元组 (2, 3, 0, 4)、(Jane Doe, 234111001, 地理学, 3.14) 以及 ($a_1$，$a_2$，$a_3$，$a_4$) 用投影 $P_{1,3}$ 时，结果应为 (2, 0)、(Jane Doe, 地理学) 和 $(a_1, a_3)$。</p>
<ul>
<li><strong>连接</strong></li>
</ul>
<p>设 R 为 m 元关系，S 为 n 元关系。连接运算 $J_p(R, S)$ 是 m + n - p 元关系，其中 $p \leq m$ 和 $p \leq n$，它包含了所有的 (m + n - p) 元组 $(a_1,a_2,…,a_{m-p},c_1,c_2,…,c_p,b_1,b_2,…,b_{n-p})$。其中 m 元组 $(a_1,a_2,…,a_{m-p},c_1,c_2,…,c_p)$ 属于 R 且 n 元组 $(c_1,c_2,…,c_p,b_1,b_2,…,b_{n-p})$ 属于 S。</p>
<p>同样，我们通过举例帮助理解：</p>
<table>
<thead>
<tr>
<th>列A</th>
<th>列B</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>b</td>
</tr>
<tr>
<td>c</td>
<td>d</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>列B</th>
<th>列C</th>
</tr>
</thead>
<tbody><tr>
<td>b</td>
<td>B</td>
</tr>
</tbody></table>
<p>将上述两表进行连接运算 $J_1$，将会得到：</p>
<table>
<thead>
<tr>
<th>列A</th>
<th>列B</th>
<th>列C</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>b</td>
<td>B</td>
</tr>
</tbody></table>
<p>可以发现：连接运算 $J_p$ 将 m 元组的后 p 个分量与 n 元组的前 p 个分量相同的第一个关系中的所有 m 元组和第二个关系的所有 n 元组组合产生一个新的关系。</p>
<p>不难发现，上述运算可以和我们熟悉的 SQL 多表查询做类比：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_a, column_b</span><br><span class="line"><span class="keyword">FROM</span> table_a, table_b</span><br><span class="line"><span class="keyword">WHERE</span> &quot;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="六、关系的表示"><a href="#六、关系的表示" class="headerlink" title="六、关系的表示"></a>六、关系的表示</h3><ul>
<li><strong>用矩阵表示关系</strong></li>
</ul>
<p>可以用一个 0-1 矩阵来表示一个有穷集之间的关系。假设 R 是从 $A = {a_1,a_2,…,a_m}$ 到 $B={b_1,b_2,…b_n}$ 的关系。关系 R 可以用矩阵 $M_R = [m_{ij}]$ 来表示，其中：$m_{ij}=\begin{cases} 1 \text{$(a_i,b_j)\in R$} \0 \text{$(a_i,b_j)\notin R$} \end{cases}$</p>
<p>换句话说，当 $a_i$ 和 $b_j$ 有关系时表示 R 的 0-1 矩阵的 (i, j) 项为 1，当 $a_i$ 和 $b_j$ 没有关系时表示 R 的 0-1 矩阵的 (i, j) 项为 0。</p>
<ol>
<li><p>如果 $M_R$ 的主对角线上所有元素都等于 1，那么 R 是<strong>自反</strong>的。</p>
</li>
<li><p>如果对于 $M_R$ 来说，都有 $m_{ij} = m_{ji}$，那么关系 R 是<strong>对称</strong>的。</p>
</li>
<li><p>如果对于 $M_R$ 来说，如果 $m_{ij} = 1$，$i \not= j$，则 $m_{ji} = 0$;</p>
<p>换句话说：当 $i \not= j$ 时，$m_{ij} = 0$ 或 $m_{ji} = 0$;</p>
<p>那么关系 R 是<strong>反对称</strong>的。</p>
</li>
</ol>
<p><strong>关系的并、交、布尔积的矩阵表达式</strong>：</p>
<p>$M_{R_1 \bigcup R_2} = M_{R_1} \bigvee M_{R_2}$</p>
<p>$M_{R_1 \bigcap R_2} = M_{R_1} \bigwedge M_{R_2}$</p>
<p>$M_{S \circ R} = M_R \bigodot M_S$</p>
<p><strong>性质：</strong></p>
<p>$M_{R^n} = M_{R}^{[n]}$</p>
<ul>
<li><strong>用图表示关系</strong></li>
</ul>
<p>我们将一个有穷集上的关系看作一个有向图，节点 a、b 如果存在一条由 a 到 b 的有向线段，则代表 a 和 b 之间存在关系。</p>
<h3 id="七、关系的闭包"><a href="#七、关系的闭包" class="headerlink" title="七、关系的闭包"></a>七、关系的闭包</h3><p>如果存在包含 R 的具有性质 P 的关系 S，并且 S 是所有包含 R 且具有性质 P 的关系的子集，那么 S 叫做 <strong>R 的 关于性质 P 的闭包</strong>。</p>
<p>上述 P 可取：自反、传递、对称。</p>
<ul>
<li>一个关系的<strong>传递闭包</strong> 等价于 在相关的有向图确定哪些顶点对之间存在路径。</li>
<li>设 R 是集合 A 上的关系。<strong>连通性关系</strong> $R^*$ 由形如 (a, b) 的有序对构成，使得在关系 R 中，从 a 到 b 之间存在一条长度至少为 1 的路径。</li>
<li>关系 R 的<strong>传递闭包</strong>等于<strong>连通性关系</strong> $R^*$。</li>
</ul>
<p><strong>传递闭包的计算：</strong></p>
<blockquote>
<p>算法1: 设 $M_R$ 是定义在 n 个元素集合的关系 R 的 0-1 矩阵。那么传递闭包 $R^*$ 的 0-1 矩阵是 $M_{R^*} = M_R \bigvee M_R^{[2]} \bigvee M_R^{[3]} \bigvee … \bigvee M_R^{[n]}$</p>
</blockquote>
<p>但如上算法为从 n 个 $M_R$ 的布尔幂求 $M_{R^*}$，需要求 n - 1 个 0-1 矩阵的布尔积。计算每个布尔积使用 $n^2(2n-1)$ 次位运算。因此，计算这些乘积需要使用 $n^2(2n - 1)(n - 1)$ 次位运算。因此，该算法的复杂度为 $O(n^4)$，显然时间开销较大。</p>
<blockquote>
<p>沃舍尔算法：</p>
<p>假设 R 是定义在 n 个元素集合上的关系。设 $v_1$，$v_2$，…，$v_n$ 是这 n 个元素的任意排列。如果 a，$x_1$，$x_2$，…，$x_{m-1}$，b 是一条路径，它的<strong>内部顶点</strong>为 $x_1$，$x_2$，…，$x_{m-1}$，即除了第一和最后一个顶点之外出现在路径中的所有顶点。</p>
<p>沃舍尔算法的基础是构造一系列的 0-1 矩阵。这些矩阵记作 $W_0$，$W_1$，…，$W_n$，其中 $W_0 = W_R$ 是这个关系的 0-1 矩阵，且 $W_k = [\omega_{ij}^{(k)}]$。如果存在一条从 $v_i$ 到 $v_j$ 的路径使得这条路径的所有内部顶点都在集合 ${v_1,v_2,…,v_k}$,那么 $\omega_{ij}^{(k)}$ = 1，否则为 0。</p>
<p>注意：$W_n = M_{R^*}$。因为 $M_{R^*}$ 的第 (i , j) 项是 1，当且仅当存在一条从 $v_i$ 到 $v_j$ 的路径，且全部内部顶点都在集合 ${v_1,v_2,…,v_n}$ 中。</p>
</blockquote>
<p>沃舍尔算法通过有效计算 $W_0 = M_R$，$W_1$，$W_2$，…，$W_n = M_{R^*}$ 来计算 $M_{R^*}$</p>
<h3 id="八、等价关系"><a href="#八、等价关系" class="headerlink" title="八、等价关系"></a>八、等价关系</h3><blockquote>
<p> 定义在集合 A 上的关系叫做<strong>等价关系</strong>，如果他是<strong>自反的、对称的和传递的</strong>。</p>
</blockquote>
<p>如果两个元素 a 和 b 由于等价关系而相连，则称他们是等价的。写作 a ~ b。</p>
<ul>
<li><strong>等价类</strong>：</li>
</ul>
<p>设 R 是定义在集合 A 上的等价关系。与 A 中的一个元素 a 有关系的所有元素的集合叫做 a 的等价类。A 的关于 R 的等价类记作 $[a]_R$。当只考虑一个关系的时候可以省略下标 R 并把这个等价类写作 [a]。</p>
<p>换句话说，如果 R 是定义在集合 A 上的等价关系，则<strong>元素 a 的等价类</strong>是：$[a]_R = {s|(a, s) \in R }$</p>
<p>如果 $b \in [a]_R$，b 叫做这个等价类的<strong>代表元</strong>。一个等价类的任何元素都可以作为这个类的代表元。</p>
<blockquote>
<p>定理：设 R 是定义在集合 A 上的等价关系，下面的关于集合 A 中 a、b 两个元素的命题是等价的。</p>
<ol>
<li>aRb</li>
<li>[a] = [b]</li>
<li>[a] $\bigcap$ [b] $\not=$ $\emptyset$</li>
</ol>
</blockquote>
<ul>
<li><p>现在将说明一个等价关系怎样<strong>划分</strong>一个集合：设 R 是定义在集合 A 上的等价关系，R 的所有等价类的并集是集合 A，因为 A 的每个元素 a 都在它自己的等价类中。换句话说 $\bigcup _{a \in A} [a]_R = A$。</p>
<p>更确切地说，所有等价类的并集就是集合 A。</p>
</li>
</ul>
<blockquote>
<p>定理：设 R 是定义在集合 S 上的等价关系。那么 R 的等价类构成 S 的划分。反过来，给定集合 S 的划分 ${A_i | i \in I}$，则存在一个等价关系 R，它以集合 $A_i(i \in I)$ 作为它的等价类。</p>
</blockquote>
<h3 id="九、偏序"><a href="#九、偏序" class="headerlink" title="九、偏序"></a>九、偏序</h3><p>定义在集合 S 上的关系 R，如果它是自反的、反对称的、传递的，就称为<strong>偏序</strong>。集合 S 与定义在其上的偏序 R 一起称为<strong>偏序集</strong>，记作 (S, R)。集合 S 中的成员称为偏序集的元素。</p>
<p>偏序集 (S, $\leq$) 中的元素 a 和 b 称为<strong>可比</strong>的。当 a 和 b 是 S 中的元素并且既没有 $a \leq b$，也没有 $b \leq a$，则称 a 和 b 是<strong>不可比</strong>的。</p>
<p>偏序集 (S, $\leq$) 是偏序集，且 S 中的每对元素都是可比的，则 S 称为<strong>全序集</strong>或线序集，且 $\leq$ 被称为全序。</p>
<p>对于偏序集 (S, $\leq$)，如果 $\leq$ 是全序，并且 S 的每个非空子集都有一个最小元素，则称为<strong>良序集</strong>。</p>
<ul>
<li><strong>哈塞图</strong></li>
</ul>
<p>我们可以从一个例子来理解哈塞图：已知集合 {1, 2, 3, 4} 上的偏序 {(a, b) | $a \leq b$}，则可以画出有向图如图a。由于这个关系是偏序的，所以必然是自反的，因此我们省略顶点到自身的环得到图 b。再者，我们假设所有的线段都是自下而上的，同时借助关系的传递性，我们可以得到图 c。</p>
<img src="http://qiniu.xuyuyan.cn/20210125.png" style="zoom:40%;" />

<h3 id="十、极大元和极小元"><a href="#十、极大元和极小元" class="headerlink" title="十、极大元和极小元"></a>十、极大元和极小元</h3><p>如果偏序集中的一个元素不小于这个偏序集中的其他元素，则称为<strong>极大元</strong>。反之，称为<strong>极小元</strong>。</p>
<p>通过哈塞图可以很容易识别极大元和极小元，分别为最顶部和最底部的元素。</p>
<ul>
<li><strong>上界和下界</strong>：</li>
</ul>
<p>有时候可以找到一个元素大于或等于偏序集 (S, $\leq$) 的子集 A 中的所有元素。如果 u 是 S 中的元素，使得对所有的元素 $a \in A$，有 $a \leq u$，那么 u 称为 A 的一个<strong>上界</strong>。如果一个上界 x 小于 A 的任何其他上界，则称为<strong>最小上界</strong>。</p>
<ul>
<li><strong>格</strong>：</li>
</ul>
<p>如果一个偏序集的每对元素都有最小上界和最大下界，就称这个偏序集为<strong>格</strong>。</p>
<h3 id="十一、拓扑排序"><a href="#十一、拓扑排序" class="headerlink" title="十一、拓扑排序"></a>十一、拓扑排序</h3><p>我们定义：如果只要 $aRb$ 就有 $a \leq b$，则称一个全序 $\leq$ 与偏序 R 是<strong>相容</strong>的。</p>
<p>从一个偏序构造一个相容的全序称为<strong>拓扑排序</strong>。</p>
<blockquote>
<p>参考书籍：《离散数学及其应用》Kenneth H. Rosen 著</p>
</blockquote>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>xyy</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://www.xuyuyan.cn/2021/01/25/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%C2%B7%E5%85%B3%E7%B3%BB/">http://www.xuyuyan.cn/2021/01/25/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%C2%B7%E5%85%B3%E7%B3%BB/</a></span>
                    </p>
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"># 离散数学</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2021/02/04/%E5%B0%8F%E8%A7%A3%E5%88%86%E6%B2%BB/">小解分治</a>
            
            
            <a class="next" rel="next" href="/2021/01/24/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%C2%B7%E6%95%B0%E8%AE%BA%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6/">离散数学·数论和密码学</a>
            
        </section>


    </article>
</div>


    <div id="gitalk-container"></div>
    <link rel="stylesheet" href="//unpkg.com/gitalk/dist/gitalk.css">
<script src="//unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
      var gitalk = new Gitalk({
        clientID: '4283629b368b1cf98f81',
        clientSecret: '8bb6ce27010c0db8286e943f3765aeae1757de4d',
        repo: 'xyyBlog',
        owner: 'rdzfv',
        admin: 'rdzfv',
        id: md5(location.pathname),      
        labels: 'Gitalk'.split(',').filter(l => l),
        perPage: 10,
        pagerDirection: 'last',
        createIssueManually: true,
        distractionFreeMode: true
      })
      gitalk.render('gitalk-container')
</script>



        </div>
        <footer id="footer" class="footer">
   <div class="copyright">
    <div style="position:fixed;left:8%;bottom:5%;">
        <div id="webpushr-subscription-button" data-button-text="订阅本站" data-subscriber-count-text="人已订阅" data-background-color="#000000"></div>
    </div>
    <div style="display:inline-block;">
        <div> <a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/" style="text-decoration: none;color: black;" >浙ICP备19012712号</a> </div>
        <span>© xyy | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
